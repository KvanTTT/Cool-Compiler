//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g 2012-01-27 23:47:03

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019

#pragma warning disable 3021

using System.Text;

using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace CoolCompiler
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class CoolGrammarParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ASSIGN", "ATSIGN", "AtSignTypeName", "BoolTypeName", "BooleanValue", "CASE", "CLASS", "COLON", "COMMA", "COMMENT", "CaseExp", "Class", "ClassesList", "Curly", "DIGIT", "DIV", "DOT", "ELSE", "EQUAL", "ESAC", "Expr", "Exprs", "FALSE", "FI", "FeatureList", "FuncDef", "FunctionArgsList", "GE", "GT", "HENCE", "ID", "IF", "IN", "INHERITS", "INTEGER", "ISVOID", "IdValue", "ImplicitInvoke", "IntTypeName", "IntegerValue", "InvokeExprs", "LCURLY", "LE", "LET", "LETTER", "LOOP", "LPAREN", "LT", "LetExprs", "LocalOrFieldInit", "MINUS", "MULT", "MULTILINE_COMMENT", "NEG", "NEW", "NOT", "OF", "ObjectTypeName", "PLUS", "POOL", "RCURLY", "RPAREN", "SELF", "SEMI", "STRING", "SelfTypeTypeName", "SelfValue", "StringTypeName", "StringValue", "THEN", "TRUE", "Term", "VOID", "VoidValue", "WHILE", "WS"
	};
	public const int EOF=-1;
	public const int ASSIGN=4;
	public const int ATSIGN=5;
	public const int AtSignTypeName=6;
	public const int BoolTypeName=7;
	public const int BooleanValue=8;
	public const int CASE=9;
	public const int CLASS=10;
	public const int COLON=11;
	public const int COMMA=12;
	public const int COMMENT=13;
	public const int CaseExp=14;
	public const int Class=15;
	public const int ClassesList=16;
	public const int Curly=17;
	public const int DIGIT=18;
	public const int DIV=19;
	public const int DOT=20;
	public const int ELSE=21;
	public const int EQUAL=22;
	public const int ESAC=23;
	public const int Expr=24;
	public const int Exprs=25;
	public const int FALSE=26;
	public const int FI=27;
	public const int FeatureList=28;
	public const int FuncDef=29;
	public const int FunctionArgsList=30;
	public const int GE=31;
	public const int GT=32;
	public const int HENCE=33;
	public const int ID=34;
	public const int IF=35;
	public const int IN=36;
	public const int INHERITS=37;
	public const int INTEGER=38;
	public const int ISVOID=39;
	public const int IdValue=40;
	public const int ImplicitInvoke=41;
	public const int IntTypeName=42;
	public const int IntegerValue=43;
	public const int InvokeExprs=44;
	public const int LCURLY=45;
	public const int LE=46;
	public const int LET=47;
	public const int LETTER=48;
	public const int LOOP=49;
	public const int LPAREN=50;
	public const int LT=51;
	public const int LetExprs=52;
	public const int LocalOrFieldInit=53;
	public const int MINUS=54;
	public const int MULT=55;
	public const int MULTILINE_COMMENT=56;
	public const int NEG=57;
	public const int NEW=58;
	public const int NOT=59;
	public const int OF=60;
	public const int ObjectTypeName=61;
	public const int PLUS=62;
	public const int POOL=63;
	public const int RCURLY=64;
	public const int RPAREN=65;
	public const int SELF=66;
	public const int SEMI=67;
	public const int STRING=68;
	public const int SelfTypeTypeName=69;
	public const int SelfValue=70;
	public const int StringTypeName=71;
	public const int StringValue=72;
	public const int THEN=73;
	public const int TRUE=74;
	public const int Term=75;
	public const int VOID=76;
	public const int VoidValue=77;
	public const int WHILE=78;
	public const int WS=79;

	public CoolGrammarParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public CoolGrammarParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return CoolGrammarParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:53:8: public program : ( classDef SEMI )+ -> ^( ClassesList ( classDef )+ ) ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<CommonTree, CommonToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken SEMI2 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> classDef1 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree SEMI2_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_classDef=new RewriteRuleSubtreeStream(adaptor,"rule classDef");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(53, 45);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:53:15: ( ( classDef SEMI )+ -> ^( ClassesList ( classDef )+ ) )
			DebugEnterAlt(1);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:54:2: ( classDef SEMI )+
			{
			DebugLocation(54, 2);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:54:2: ( classDef SEMI )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==CLASS))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:54:3: classDef SEMI
					{
					DebugLocation(54, 3);
					PushFollow(Follow._classDef_in_program181);
					classDef1=classDef();
					PopFollow();

					stream_classDef.Add(classDef1.Tree);
					DebugLocation(54, 12);
					SEMI2=(CommonToken)Match(input,SEMI,Follow._SEMI_in_program183);  
					stream_SEMI.Add(SEMI2);


					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }



			{
			// AST REWRITE
			// elements: classDef
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 54:19: -> ^( ClassesList ( classDef )+ )
			{
				DebugLocation(54, 22);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:54:22: ^( ClassesList ( classDef )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(54, 24);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ClassesList, "ClassesList"), root_1);

				DebugLocation(54, 36);
				if (!(stream_classDef.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_classDef.HasNext )
				{
					DebugLocation(54, 36);
					adaptor.AddChild(root_1, stream_classDef.NextTree());

				}
				stream_classDef.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(54, 45);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_classDef();
	partial void LeaveRule_classDef();

	// $ANTLR start "classDef"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:56:1: classDef : CLASS typeName ( INHERITS typeName )? LCURLY featureList RCURLY -> ^( Class typeName featureList ( typeName )? ) ;
	[GrammarRule("classDef")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> classDef()
	{
		EnterRule_classDef();
		EnterRule("classDef", 2);
		TraceIn("classDef", 2);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken CLASS3 = default(CommonToken);
		CommonToken INHERITS5 = default(CommonToken);
		CommonToken LCURLY7 = default(CommonToken);
		CommonToken RCURLY9 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName4 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName6 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> featureList8 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree CLASS3_tree = default(CommonTree);
		CommonTree INHERITS5_tree = default(CommonTree);
		CommonTree LCURLY7_tree = default(CommonTree);
		CommonTree RCURLY9_tree = default(CommonTree);
		RewriteRuleITokenStream stream_CLASS=new RewriteRuleITokenStream(adaptor,"token CLASS");
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_INHERITS=new RewriteRuleITokenStream(adaptor,"token INHERITS");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_typeName=new RewriteRuleSubtreeStream(adaptor,"rule typeName");
		RewriteRuleSubtreeStream stream_featureList=new RewriteRuleSubtreeStream(adaptor,"rule featureList");
		try { DebugEnterRule(GrammarFileName, "classDef");
		DebugLocation(56, 41);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:56:9: ( CLASS typeName ( INHERITS typeName )? LCURLY featureList RCURLY -> ^( Class typeName featureList ( typeName )? ) )
			DebugEnterAlt(1);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:57:2: CLASS typeName ( INHERITS typeName )? LCURLY featureList RCURLY
			{
			DebugLocation(57, 2);
			CLASS3=(CommonToken)Match(input,CLASS,Follow._CLASS_in_classDef204);  
			stream_CLASS.Add(CLASS3);

			DebugLocation(57, 8);
			PushFollow(Follow._typeName_in_classDef206);
			typeName4=typeName();
			PopFollow();

			stream_typeName.Add(typeName4.Tree);
			DebugLocation(57, 17);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:57:17: ( INHERITS typeName )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==INHERITS))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:57:18: INHERITS typeName
				{
				DebugLocation(57, 18);
				INHERITS5=(CommonToken)Match(input,INHERITS,Follow._INHERITS_in_classDef209);  
				stream_INHERITS.Add(INHERITS5);

				DebugLocation(57, 27);
				PushFollow(Follow._typeName_in_classDef211);
				typeName6=typeName();
				PopFollow();

				stream_typeName.Add(typeName6.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(57, 38);
			LCURLY7=(CommonToken)Match(input,LCURLY,Follow._LCURLY_in_classDef215);  
			stream_LCURLY.Add(LCURLY7);

			DebugLocation(57, 45);
			PushFollow(Follow._featureList_in_classDef217);
			featureList8=featureList();
			PopFollow();

			stream_featureList.Add(featureList8.Tree);
			DebugLocation(57, 57);
			RCURLY9=(CommonToken)Match(input,RCURLY,Follow._RCURLY_in_classDef219);  
			stream_RCURLY.Add(RCURLY9);



			{
			// AST REWRITE
			// elements: featureList, typeName, typeName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 57:64: -> ^( Class typeName featureList ( typeName )? )
			{
				DebugLocation(58, 3);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:58:3: ^( Class typeName featureList ( typeName )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(58, 5);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Class, "Class"), root_1);

				DebugLocation(58, 11);
				adaptor.AddChild(root_1, stream_typeName.NextTree());
				DebugLocation(58, 20);
				adaptor.AddChild(root_1, stream_featureList.NextTree());
				DebugLocation(58, 32);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:58:32: ( typeName )?
				if (stream_typeName.HasNext)
				{
					DebugLocation(58, 32);
					adaptor.AddChild(root_1, stream_typeName.NextTree());

				}
				stream_typeName.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("classDef", 2);
			LeaveRule("classDef", 2);
			LeaveRule_classDef();
		}
		DebugLocation(58, 41);
		} finally { DebugExitRule(GrammarFileName, "classDef"); }
		return retval;

	}
	// $ANTLR end "classDef"

	partial void EnterRule_featureList();
	partial void LeaveRule_featureList();

	// $ANTLR start "featureList"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:60:1: featureList : ( feature SEMI )* -> ^( FeatureList ( feature )* ) ;
	[GrammarRule("featureList")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> featureList()
	{
		EnterRule_featureList();
		EnterRule("featureList", 3);
		TraceIn("featureList", 3);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken SEMI11 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> feature10 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree SEMI11_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_feature=new RewriteRuleSubtreeStream(adaptor,"rule feature");
		try { DebugEnterRule(GrammarFileName, "featureList");
		DebugLocation(60, 43);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:60:12: ( ( feature SEMI )* -> ^( FeatureList ( feature )* ) )
			DebugEnterAlt(1);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:61:2: ( feature SEMI )*
			{
			DebugLocation(61, 2);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:61:2: ( feature SEMI )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0==ID))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:61:3: feature SEMI
					{
					DebugLocation(61, 3);
					PushFollow(Follow._feature_in_featureList245);
					feature10=feature();
					PopFollow();

					stream_feature.Add(feature10.Tree);
					DebugLocation(61, 11);
					SEMI11=(CommonToken)Match(input,SEMI,Follow._SEMI_in_featureList247);  
					stream_SEMI.Add(SEMI11);


					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }



			{
			// AST REWRITE
			// elements: feature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 61:18: -> ^( FeatureList ( feature )* )
			{
				DebugLocation(61, 21);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:61:21: ^( FeatureList ( feature )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(61, 23);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FeatureList, "FeatureList"), root_1);

				DebugLocation(61, 35);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:61:35: ( feature )*
				while ( stream_feature.HasNext )
				{
					DebugLocation(61, 35);
					adaptor.AddChild(root_1, stream_feature.NextTree());

				}
				stream_feature.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("featureList", 3);
			LeaveRule("featureList", 3);
			LeaveRule_featureList();
		}
		DebugLocation(61, 43);
		} finally { DebugExitRule(GrammarFileName, "featureList"); }
		return retval;

	}
	// $ANTLR end "featureList"

	partial void EnterRule_feature();
	partial void LeaveRule_feature();

	// $ANTLR start "feature"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:63:1: feature : ( ( ID LPAREN ( formalList )? RPAREN COLON typeName LCURLY expr RCURLY ) -> ^( FuncDef ID typeName expr ( formalList )? ) | localOrFieldInit );
	[GrammarRule("feature")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> feature()
	{
		EnterRule_feature();
		EnterRule("feature", 4);
		TraceIn("feature", 4);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ID12 = default(CommonToken);
		CommonToken LPAREN13 = default(CommonToken);
		CommonToken RPAREN15 = default(CommonToken);
		CommonToken COLON16 = default(CommonToken);
		CommonToken LCURLY18 = default(CommonToken);
		CommonToken RCURLY20 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> formalList14 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName17 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr19 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> localOrFieldInit21 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ID12_tree = default(CommonTree);
		CommonTree LPAREN13_tree = default(CommonTree);
		CommonTree RPAREN15_tree = default(CommonTree);
		CommonTree COLON16_tree = default(CommonTree);
		CommonTree LCURLY18_tree = default(CommonTree);
		CommonTree RCURLY20_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_typeName=new RewriteRuleSubtreeStream(adaptor,"rule typeName");
		RewriteRuleSubtreeStream stream_formalList=new RewriteRuleSubtreeStream(adaptor,"rule formalList");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "feature");
		DebugLocation(63, 22);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:63:8: ( ( ID LPAREN ( formalList )? RPAREN COLON typeName LCURLY expr RCURLY ) -> ^( FuncDef ID typeName expr ( formalList )? ) | localOrFieldInit )
			int alt5=2;
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==ID))
			{
				int LA5_1 = input.LA(2);

				if ((LA5_1==LPAREN))
				{
					alt5 = 1;
				}
				else if ((LA5_1==COLON))
				{
					alt5 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 5, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:64:3: ( ID LPAREN ( formalList )? RPAREN COLON typeName LCURLY expr RCURLY )
				{
				DebugLocation(64, 3);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:64:3: ( ID LPAREN ( formalList )? RPAREN COLON typeName LCURLY expr RCURLY )
				DebugEnterAlt(1);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:64:4: ID LPAREN ( formalList )? RPAREN COLON typeName LCURLY expr RCURLY
				{
				DebugLocation(64, 4);
				ID12=(CommonToken)Match(input,ID,Follow._ID_in_feature270);  
				stream_ID.Add(ID12);

				DebugLocation(64, 7);
				LPAREN13=(CommonToken)Match(input,LPAREN,Follow._LPAREN_in_feature272);  
				stream_LPAREN.Add(LPAREN13);

				DebugLocation(64, 14);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:64:14: ( formalList )?
				int alt4=2;
				try { DebugEnterSubRule(4);
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==ID))
				{
					alt4 = 1;
				}
				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:64:15: formalList
					{
					DebugLocation(64, 15);
					PushFollow(Follow._formalList_in_feature275);
					formalList14=formalList();
					PopFollow();

					stream_formalList.Add(formalList14.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(4); }

				DebugLocation(64, 28);
				RPAREN15=(CommonToken)Match(input,RPAREN,Follow._RPAREN_in_feature279);  
				stream_RPAREN.Add(RPAREN15);

				DebugLocation(64, 35);
				COLON16=(CommonToken)Match(input,COLON,Follow._COLON_in_feature281);  
				stream_COLON.Add(COLON16);

				DebugLocation(64, 41);
				PushFollow(Follow._typeName_in_feature283);
				typeName17=typeName();
				PopFollow();

				stream_typeName.Add(typeName17.Tree);
				DebugLocation(64, 50);
				LCURLY18=(CommonToken)Match(input,LCURLY,Follow._LCURLY_in_feature285);  
				stream_LCURLY.Add(LCURLY18);

				DebugLocation(64, 57);
				PushFollow(Follow._expr_in_feature287);
				expr19=expr();
				PopFollow();

				stream_expr.Add(expr19.Tree);
				DebugLocation(64, 62);
				RCURLY20=(CommonToken)Match(input,RCURLY,Follow._RCURLY_in_feature289);  
				stream_RCURLY.Add(RCURLY20);


				}



				{
				// AST REWRITE
				// elements: typeName, formalList, ID, expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 64:70: -> ^( FuncDef ID typeName expr ( formalList )? )
				{
					DebugLocation(65, 4);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:65:4: ^( FuncDef ID typeName expr ( formalList )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(65, 6);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FuncDef, "FuncDef"), root_1);

					DebugLocation(65, 14);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(65, 17);
					adaptor.AddChild(root_1, stream_typeName.NextTree());
					DebugLocation(65, 26);
					adaptor.AddChild(root_1, stream_expr.NextTree());
					DebugLocation(65, 31);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:65:31: ( formalList )?
					if (stream_formalList.HasNext)
					{
						DebugLocation(65, 31);
						adaptor.AddChild(root_1, stream_formalList.NextTree());

					}
					stream_formalList.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:66:6: localOrFieldInit
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(66, 6);
				PushFollow(Follow._localOrFieldInit_in_feature316);
				localOrFieldInit21=localOrFieldInit();
				PopFollow();

				adaptor.AddChild(root_0, localOrFieldInit21.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("feature", 4);
			LeaveRule("feature", 4);
			LeaveRule_feature();
		}
		DebugLocation(66, 22);
		} finally { DebugExitRule(GrammarFileName, "feature"); }
		return retval;

	}
	// $ANTLR end "feature"

	partial void EnterRule_formalList();
	partial void LeaveRule_formalList();

	// $ANTLR start "formalList"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:68:1: formalList : formal ( COMMA formal )* -> ^( FunctionArgsList ( formal )+ ) ;
	[GrammarRule("formalList")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> formalList()
	{
		EnterRule_formalList();
		EnterRule("formalList", 5);
		TraceIn("formalList", 5);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken COMMA23 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> formal22 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> formal24 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree COMMA23_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_formal=new RewriteRuleSubtreeStream(adaptor,"rule formal");
		try { DebugEnterRule(GrammarFileName, "formalList");
		DebugLocation(68, 54);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:68:11: ( formal ( COMMA formal )* -> ^( FunctionArgsList ( formal )+ ) )
			DebugEnterAlt(1);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:69:2: formal ( COMMA formal )*
			{
			DebugLocation(69, 2);
			PushFollow(Follow._formal_in_formalList325);
			formal22=formal();
			PopFollow();

			stream_formal.Add(formal22.Tree);
			DebugLocation(69, 9);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:69:9: ( COMMA formal )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==COMMA))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:69:10: COMMA formal
					{
					DebugLocation(69, 10);
					COMMA23=(CommonToken)Match(input,COMMA,Follow._COMMA_in_formalList328);  
					stream_COMMA.Add(COMMA23);

					DebugLocation(69, 16);
					PushFollow(Follow._formal_in_formalList330);
					formal24=formal();
					PopFollow();

					stream_formal.Add(formal24.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }



			{
			// AST REWRITE
			// elements: formal
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 69:25: -> ^( FunctionArgsList ( formal )+ )
			{
				DebugLocation(69, 28);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:69:28: ^( FunctionArgsList ( formal )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(69, 30);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FunctionArgsList, "FunctionArgsList"), root_1);

				DebugLocation(69, 47);
				if (!(stream_formal.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_formal.HasNext )
				{
					DebugLocation(69, 47);
					adaptor.AddChild(root_1, stream_formal.NextTree());

				}
				stream_formal.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("formalList", 5);
			LeaveRule("formalList", 5);
			LeaveRule_formalList();
		}
		DebugLocation(69, 54);
		} finally { DebugExitRule(GrammarFileName, "formalList"); }
		return retval;

	}
	// $ANTLR end "formalList"

	partial void EnterRule_formal();
	partial void LeaveRule_formal();

	// $ANTLR start "formal"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:71:1: formal : ID COLON ^ typeName ;
	[GrammarRule("formal")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> formal()
	{
		EnterRule_formal();
		EnterRule("formal", 6);
		TraceIn("formal", 6);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ID25 = default(CommonToken);
		CommonToken COLON26 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName27 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ID25_tree = default(CommonTree);
		CommonTree COLON26_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "formal");
		DebugLocation(71, 26);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:71:7: ( ID COLON ^ typeName )
			DebugEnterAlt(1);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:71:9: ID COLON ^ typeName
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(71, 9);
			ID25=(CommonToken)Match(input,ID,Follow._ID_in_formal348); 
			ID25_tree = (CommonTree)adaptor.Create(ID25);
			adaptor.AddChild(root_0, ID25_tree);
			DebugLocation(71, 17);
			COLON26=(CommonToken)Match(input,COLON,Follow._COLON_in_formal350); 
			COLON26_tree = (CommonTree)adaptor.Create(COLON26);
			root_0 = (CommonTree)adaptor.BecomeRoot(COLON26_tree, root_0);
			DebugLocation(71, 19);
			PushFollow(Follow._typeName_in_formal353);
			typeName27=typeName();
			PopFollow();

			adaptor.AddChild(root_0, typeName27.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("formal", 6);
			LeaveRule("formal", 6);
			LeaveRule_formal();
		}
		DebugLocation(71, 26);
		} finally { DebugExitRule(GrammarFileName, "formal"); }
		return retval;

	}
	// $ANTLR end "formal"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:73:1: expr : ( ID ASSIGN ^)* not ;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 7);
		TraceIn("expr", 7);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ID28 = default(CommonToken);
		CommonToken ASSIGN29 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> not30 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ID28_tree = default(CommonTree);
		CommonTree ASSIGN29_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(73, 18);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:73:5: ( ( ID ASSIGN ^)* not )
			DebugEnterAlt(1);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:74:2: ( ID ASSIGN ^)* not
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(74, 2);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:74:2: ( ID ASSIGN ^)*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if ((LA7_0==ID))
				{
					int LA7_2 = input.LA(2);

					if ((LA7_2==ASSIGN))
					{
						alt7 = 1;
					}


				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:74:3: ID ASSIGN ^
					{
					DebugLocation(74, 3);
					ID28=(CommonToken)Match(input,ID,Follow._ID_in_expr362); 
					ID28_tree = (CommonTree)adaptor.Create(ID28);
					adaptor.AddChild(root_0, ID28_tree);
					DebugLocation(74, 12);
					ASSIGN29=(CommonToken)Match(input,ASSIGN,Follow._ASSIGN_in_expr364); 
					ASSIGN29_tree = (CommonTree)adaptor.Create(ASSIGN29);
					root_0 = (CommonTree)adaptor.BecomeRoot(ASSIGN29_tree, root_0);

					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(74, 16);
			PushFollow(Follow._not_in_expr369);
			not30=not();
			PopFollow();

			adaptor.AddChild(root_0, not30.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("expr", 7);
			LeaveRule("expr", 7);
			LeaveRule_expr();
		}
		DebugLocation(74, 18);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_not();
	partial void LeaveRule_not();

	// $ANTLR start "not"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:76:1: not : ( NOT ^)* relation ;
	[GrammarRule("not")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> not()
	{
		EnterRule_not();
		EnterRule("not", 8);
		TraceIn("not", 8);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken NOT31 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> relation32 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree NOT31_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "not");
		DebugLocation(76, 17);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:76:4: ( ( NOT ^)* relation )
			DebugEnterAlt(1);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:77:2: ( NOT ^)* relation
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(77, 2);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:77:2: ( NOT ^)*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==NOT))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:77:3: NOT ^
					{
					DebugLocation(77, 6);
					NOT31=(CommonToken)Match(input,NOT,Follow._NOT_in_not380); 
					NOT31_tree = (CommonTree)adaptor.Create(NOT31);
					root_0 = (CommonTree)adaptor.BecomeRoot(NOT31_tree, root_0);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(77, 10);
			PushFollow(Follow._relation_in_not385);
			relation32=relation();
			PopFollow();

			adaptor.AddChild(root_0, relation32.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("not", 8);
			LeaveRule("not", 8);
			LeaveRule_not();
		}
		DebugLocation(77, 17);
		} finally { DebugExitRule(GrammarFileName, "not"); }
		return retval;

	}
	// $ANTLR end "not"

	partial void EnterRule_relation();
	partial void LeaveRule_relation();

	// $ANTLR start "relation"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:79:1: relation : addition ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) addition )* ;
	[GrammarRule("relation")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> relation()
	{
		EnterRule_relation();
		EnterRule("relation", 9);
		TraceIn("relation", 9);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken LE34 = default(CommonToken);
		CommonToken LT35 = default(CommonToken);
		CommonToken GE36 = default(CommonToken);
		CommonToken GT37 = default(CommonToken);
		CommonToken EQUAL38 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> addition33 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> addition39 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree LE34_tree = default(CommonTree);
		CommonTree LT35_tree = default(CommonTree);
		CommonTree GE36_tree = default(CommonTree);
		CommonTree GT37_tree = default(CommonTree);
		CommonTree EQUAL38_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "relation");
		DebugLocation(79, 54);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:79:9: ( addition ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) addition )* )
			DebugEnterAlt(1);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:80:2: addition ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) addition )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(80, 2);
			PushFollow(Follow._addition_in_relation394);
			addition33=addition();
			PopFollow();

			adaptor.AddChild(root_0, addition33.Tree);
			DebugLocation(80, 11);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:80:11: ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) addition )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==EQUAL||(LA10_0>=GE && LA10_0<=GT)||LA10_0==LE||LA10_0==LT))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:80:12: ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) addition
					{
					DebugLocation(80, 12);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:80:12: ( LE ^| LT ^| GE ^| GT ^| EQUAL ^)
					int alt9=5;
					try { DebugEnterSubRule(9);
					try { DebugEnterDecision(9, false);
					switch (input.LA(1))
					{
					case LE:
						{
						alt9 = 1;
						}
						break;
					case LT:
						{
						alt9 = 2;
						}
						break;
					case GE:
						{
						alt9 = 3;
						}
						break;
					case GT:
						{
						alt9 = 4;
						}
						break;
					case EQUAL:
						{
						alt9 = 5;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(9); }
					switch (alt9)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:80:13: LE ^
						{
						DebugLocation(80, 15);
						LE34=(CommonToken)Match(input,LE,Follow._LE_in_relation398); 
						LE34_tree = (CommonTree)adaptor.Create(LE34);
						root_0 = (CommonTree)adaptor.BecomeRoot(LE34_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:80:19: LT ^
						{
						DebugLocation(80, 21);
						LT35=(CommonToken)Match(input,LT,Follow._LT_in_relation403); 
						LT35_tree = (CommonTree)adaptor.Create(LT35);
						root_0 = (CommonTree)adaptor.BecomeRoot(LT35_tree, root_0);

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:80:25: GE ^
						{
						DebugLocation(80, 27);
						GE36=(CommonToken)Match(input,GE,Follow._GE_in_relation408); 
						GE36_tree = (CommonTree)adaptor.Create(GE36);
						root_0 = (CommonTree)adaptor.BecomeRoot(GE36_tree, root_0);

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:80:31: GT ^
						{
						DebugLocation(80, 33);
						GT37=(CommonToken)Match(input,GT,Follow._GT_in_relation413); 
						GT37_tree = (CommonTree)adaptor.Create(GT37);
						root_0 = (CommonTree)adaptor.BecomeRoot(GT37_tree, root_0);

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:80:37: EQUAL ^
						{
						DebugLocation(80, 42);
						EQUAL38=(CommonToken)Match(input,EQUAL,Follow._EQUAL_in_relation418); 
						EQUAL38_tree = (CommonTree)adaptor.Create(EQUAL38);
						root_0 = (CommonTree)adaptor.BecomeRoot(EQUAL38_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(9); }

					DebugLocation(80, 45);
					PushFollow(Follow._addition_in_relation422);
					addition39=addition();
					PopFollow();

					adaptor.AddChild(root_0, addition39.Tree);

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("relation", 9);
			LeaveRule("relation", 9);
			LeaveRule_relation();
		}
		DebugLocation(80, 54);
		} finally { DebugExitRule(GrammarFileName, "relation"); }
		return retval;

	}
	// $ANTLR end "relation"

	partial void EnterRule_addition();
	partial void LeaveRule_addition();

	// $ANTLR start "addition"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:82:1: addition : multiplication ( ( PLUS ^| MINUS ^) multiplication )* ;
	[GrammarRule("addition")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> addition()
	{
		EnterRule_addition();
		EnterRule("addition", 10);
		TraceIn("addition", 10);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken PLUS41 = default(CommonToken);
		CommonToken MINUS42 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> multiplication40 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> multiplication43 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree PLUS41_tree = default(CommonTree);
		CommonTree MINUS42_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "addition");
		DebugLocation(82, 50);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:82:9: ( multiplication ( ( PLUS ^| MINUS ^) multiplication )* )
			DebugEnterAlt(1);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:83:2: multiplication ( ( PLUS ^| MINUS ^) multiplication )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(83, 2);
			PushFollow(Follow._multiplication_in_addition433);
			multiplication40=multiplication();
			PopFollow();

			adaptor.AddChild(root_0, multiplication40.Tree);
			DebugLocation(83, 17);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:83:17: ( ( PLUS ^| MINUS ^) multiplication )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==MINUS||LA12_0==PLUS))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:83:18: ( PLUS ^| MINUS ^) multiplication
					{
					DebugLocation(83, 18);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:83:18: ( PLUS ^| MINUS ^)
					int alt11=2;
					try { DebugEnterSubRule(11);
					try { DebugEnterDecision(11, false);
					int LA11_0 = input.LA(1);

					if ((LA11_0==PLUS))
					{
						alt11 = 1;
					}
					else if ((LA11_0==MINUS))
					{
						alt11 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(11); }
					switch (alt11)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:83:19: PLUS ^
						{
						DebugLocation(83, 23);
						PLUS41=(CommonToken)Match(input,PLUS,Follow._PLUS_in_addition437); 
						PLUS41_tree = (CommonTree)adaptor.Create(PLUS41);
						root_0 = (CommonTree)adaptor.BecomeRoot(PLUS41_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:83:27: MINUS ^
						{
						DebugLocation(83, 32);
						MINUS42=(CommonToken)Match(input,MINUS,Follow._MINUS_in_addition442); 
						MINUS42_tree = (CommonTree)adaptor.Create(MINUS42);
						root_0 = (CommonTree)adaptor.BecomeRoot(MINUS42_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(11); }

					DebugLocation(83, 35);
					PushFollow(Follow._multiplication_in_addition446);
					multiplication43=multiplication();
					PopFollow();

					adaptor.AddChild(root_0, multiplication43.Tree);

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("addition", 10);
			LeaveRule("addition", 10);
			LeaveRule_addition();
		}
		DebugLocation(83, 50);
		} finally { DebugExitRule(GrammarFileName, "addition"); }
		return retval;

	}
	// $ANTLR end "addition"

	partial void EnterRule_multiplication();
	partial void LeaveRule_multiplication();

	// $ANTLR start "multiplication"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:85:1: multiplication : isvoid ( ( MULT ^| DIV ^) isvoid )* ;
	[GrammarRule("multiplication")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> multiplication()
	{
		EnterRule_multiplication();
		EnterRule("multiplication", 11);
		TraceIn("multiplication", 11);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken MULT45 = default(CommonToken);
		CommonToken DIV46 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> isvoid44 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> isvoid47 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree MULT45_tree = default(CommonTree);
		CommonTree DIV46_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "multiplication");
		DebugLocation(85, 32);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:85:15: ( isvoid ( ( MULT ^| DIV ^) isvoid )* )
			DebugEnterAlt(1);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:86:2: isvoid ( ( MULT ^| DIV ^) isvoid )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(86, 2);
			PushFollow(Follow._isvoid_in_multiplication456);
			isvoid44=isvoid();
			PopFollow();

			adaptor.AddChild(root_0, isvoid44.Tree);
			DebugLocation(86, 9);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:86:9: ( ( MULT ^| DIV ^) isvoid )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==DIV||LA14_0==MULT))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:86:10: ( MULT ^| DIV ^) isvoid
					{
					DebugLocation(86, 10);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:86:10: ( MULT ^| DIV ^)
					int alt13=2;
					try { DebugEnterSubRule(13);
					try { DebugEnterDecision(13, false);
					int LA13_0 = input.LA(1);

					if ((LA13_0==MULT))
					{
						alt13 = 1;
					}
					else if ((LA13_0==DIV))
					{
						alt13 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(13); }
					switch (alt13)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:86:11: MULT ^
						{
						DebugLocation(86, 15);
						MULT45=(CommonToken)Match(input,MULT,Follow._MULT_in_multiplication460); 
						MULT45_tree = (CommonTree)adaptor.Create(MULT45);
						root_0 = (CommonTree)adaptor.BecomeRoot(MULT45_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:86:19: DIV ^
						{
						DebugLocation(86, 22);
						DIV46=(CommonToken)Match(input,DIV,Follow._DIV_in_multiplication465); 
						DIV46_tree = (CommonTree)adaptor.Create(DIV46);
						root_0 = (CommonTree)adaptor.BecomeRoot(DIV46_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(13); }

					DebugLocation(86, 25);
					PushFollow(Follow._isvoid_in_multiplication469);
					isvoid47=isvoid();
					PopFollow();

					adaptor.AddChild(root_0, isvoid47.Tree);

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("multiplication", 11);
			LeaveRule("multiplication", 11);
			LeaveRule_multiplication();
		}
		DebugLocation(86, 32);
		} finally { DebugExitRule(GrammarFileName, "multiplication"); }
		return retval;

	}
	// $ANTLR end "multiplication"

	partial void EnterRule_isvoid();
	partial void LeaveRule_isvoid();

	// $ANTLR start "isvoid"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:88:1: isvoid : ( ISVOID ^)* neg ;
	[GrammarRule("isvoid")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> isvoid()
	{
		EnterRule_isvoid();
		EnterRule("isvoid", 12);
		TraceIn("isvoid", 12);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ISVOID48 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> neg49 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ISVOID48_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "isvoid");
		DebugLocation(88, 15);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:88:7: ( ( ISVOID ^)* neg )
			DebugEnterAlt(1);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:89:2: ( ISVOID ^)* neg
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(89, 2);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:89:2: ( ISVOID ^)*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_0 = input.LA(1);

				if ((LA15_0==ISVOID))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:89:3: ISVOID ^
					{
					DebugLocation(89, 9);
					ISVOID48=(CommonToken)Match(input,ISVOID,Follow._ISVOID_in_isvoid480); 
					ISVOID48_tree = (CommonTree)adaptor.Create(ISVOID48);
					root_0 = (CommonTree)adaptor.BecomeRoot(ISVOID48_tree, root_0);

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }

			DebugLocation(89, 13);
			PushFollow(Follow._neg_in_isvoid485);
			neg49=neg();
			PopFollow();

			adaptor.AddChild(root_0, neg49.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("isvoid", 12);
			LeaveRule("isvoid", 12);
			LeaveRule_isvoid();
		}
		DebugLocation(89, 15);
		} finally { DebugExitRule(GrammarFileName, "isvoid"); }
		return retval;

	}
	// $ANTLR end "isvoid"

	partial void EnterRule_neg();
	partial void LeaveRule_neg();

	// $ANTLR start "neg"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:91:1: neg : ( NEG ^)* dot ;
	[GrammarRule("neg")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> neg()
	{
		EnterRule_neg();
		EnterRule("neg", 13);
		TraceIn("neg", 13);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken NEG50 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> dot51 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree NEG50_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "neg");
		DebugLocation(91, 12);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:91:4: ( ( NEG ^)* dot )
			DebugEnterAlt(1);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:92:2: ( NEG ^)* dot
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(92, 2);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:92:2: ( NEG ^)*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==NEG))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:92:3: NEG ^
					{
					DebugLocation(92, 6);
					NEG50=(CommonToken)Match(input,NEG,Follow._NEG_in_neg494); 
					NEG50_tree = (CommonTree)adaptor.Create(NEG50);
					root_0 = (CommonTree)adaptor.BecomeRoot(NEG50_tree, root_0);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }

			DebugLocation(92, 10);
			PushFollow(Follow._dot_in_neg499);
			dot51=dot();
			PopFollow();

			adaptor.AddChild(root_0, dot51.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("neg", 13);
			LeaveRule("neg", 13);
			LeaveRule_neg();
		}
		DebugLocation(92, 12);
		} finally { DebugExitRule(GrammarFileName, "neg"); }
		return retval;

	}
	// $ANTLR end "neg"

	partial void EnterRule_dot();
	partial void LeaveRule_dot();

	// $ANTLR start "dot"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:94:1: dot : term ( ( ATSIGN typeName )? DOT ID LPAREN ( invokeExprs )? RPAREN )? -> ^( Term term ( ID )? ( typeName )? ( invokeExprs )? ) ;
	[GrammarRule("dot")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> dot()
	{
		EnterRule_dot();
		EnterRule("dot", 14);
		TraceIn("dot", 14);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ATSIGN53 = default(CommonToken);
		CommonToken DOT55 = default(CommonToken);
		CommonToken ID56 = default(CommonToken);
		CommonToken LPAREN57 = default(CommonToken);
		CommonToken RPAREN59 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> term52 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName54 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> invokeExprs58 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ATSIGN53_tree = default(CommonTree);
		CommonTree DOT55_tree = default(CommonTree);
		CommonTree ID56_tree = default(CommonTree);
		CommonTree LPAREN57_tree = default(CommonTree);
		CommonTree RPAREN59_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_ATSIGN=new RewriteRuleITokenStream(adaptor,"token ATSIGN");
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_typeName=new RewriteRuleSubtreeStream(adaptor,"rule typeName");
		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,"rule term");
		RewriteRuleSubtreeStream stream_invokeExprs=new RewriteRuleSubtreeStream(adaptor,"rule invokeExprs");
		try { DebugEnterRule(GrammarFileName, "dot");
		DebugLocation(94, 41);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:94:4: ( term ( ( ATSIGN typeName )? DOT ID LPAREN ( invokeExprs )? RPAREN )? -> ^( Term term ( ID )? ( typeName )? ( invokeExprs )? ) )
			DebugEnterAlt(1);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:95:2: term ( ( ATSIGN typeName )? DOT ID LPAREN ( invokeExprs )? RPAREN )?
			{
			DebugLocation(95, 2);
			PushFollow(Follow._term_in_dot507);
			term52=term();
			PopFollow();

			stream_term.Add(term52.Tree);
			DebugLocation(95, 7);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:95:7: ( ( ATSIGN typeName )? DOT ID LPAREN ( invokeExprs )? RPAREN )?
			int alt19=2;
			try { DebugEnterSubRule(19);
			try { DebugEnterDecision(19, false);
			int LA19_0 = input.LA(1);

			if ((LA19_0==ATSIGN||LA19_0==DOT))
			{
				alt19 = 1;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:95:8: ( ATSIGN typeName )? DOT ID LPAREN ( invokeExprs )? RPAREN
				{
				DebugLocation(95, 8);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:95:8: ( ATSIGN typeName )?
				int alt17=2;
				try { DebugEnterSubRule(17);
				try { DebugEnterDecision(17, false);
				int LA17_0 = input.LA(1);

				if ((LA17_0==ATSIGN))
				{
					alt17 = 1;
				}
				} finally { DebugExitDecision(17); }
				switch (alt17)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:95:9: ATSIGN typeName
					{
					DebugLocation(95, 9);
					ATSIGN53=(CommonToken)Match(input,ATSIGN,Follow._ATSIGN_in_dot511);  
					stream_ATSIGN.Add(ATSIGN53);

					DebugLocation(95, 16);
					PushFollow(Follow._typeName_in_dot513);
					typeName54=typeName();
					PopFollow();

					stream_typeName.Add(typeName54.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(17); }

				DebugLocation(95, 27);
				DOT55=(CommonToken)Match(input,DOT,Follow._DOT_in_dot517);  
				stream_DOT.Add(DOT55);

				DebugLocation(95, 31);
				ID56=(CommonToken)Match(input,ID,Follow._ID_in_dot519);  
				stream_ID.Add(ID56);

				DebugLocation(95, 34);
				LPAREN57=(CommonToken)Match(input,LPAREN,Follow._LPAREN_in_dot521);  
				stream_LPAREN.Add(LPAREN57);

				DebugLocation(95, 41);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:95:41: ( invokeExprs )?
				int alt18=2;
				try { DebugEnterSubRule(18);
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if ((LA18_0==CASE||LA18_0==FALSE||(LA18_0>=ID && LA18_0<=IF)||(LA18_0>=INTEGER && LA18_0<=ISVOID)||LA18_0==LCURLY||LA18_0==LET||LA18_0==LPAREN||(LA18_0>=NEG && LA18_0<=NOT)||LA18_0==SELF||LA18_0==STRING||LA18_0==TRUE||LA18_0==VOID||LA18_0==WHILE))
				{
					alt18 = 1;
				}
				} finally { DebugExitDecision(18); }
				switch (alt18)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:95:41: invokeExprs
					{
					DebugLocation(95, 41);
					PushFollow(Follow._invokeExprs_in_dot523);
					invokeExprs58=invokeExprs();
					PopFollow();

					stream_invokeExprs.Add(invokeExprs58.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(18); }

				DebugLocation(95, 54);
				RPAREN59=(CommonToken)Match(input,RPAREN,Follow._RPAREN_in_dot526);  
				stream_RPAREN.Add(RPAREN59);


				}
				break;

			}
			} finally { DebugExitSubRule(19); }



			{
			// AST REWRITE
			// elements: term, typeName, ID, invokeExprs
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 95:63: -> ^( Term term ( ID )? ( typeName )? ( invokeExprs )? )
			{
				DebugLocation(96, 3);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:96:3: ^( Term term ( ID )? ( typeName )? ( invokeExprs )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(96, 5);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Term, "Term"), root_1);

				DebugLocation(96, 10);
				adaptor.AddChild(root_1, stream_term.NextTree());
				DebugLocation(96, 15);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:96:15: ( ID )?
				if (stream_ID.HasNext)
				{
					DebugLocation(96, 15);
					adaptor.AddChild(root_1, stream_ID.NextNode());

				}
				stream_ID.Reset();
				DebugLocation(96, 19);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:96:19: ( typeName )?
				if (stream_typeName.HasNext)
				{
					DebugLocation(96, 19);
					adaptor.AddChild(root_1, stream_typeName.NextTree());

				}
				stream_typeName.Reset();
				DebugLocation(96, 29);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:96:29: ( invokeExprs )?
				if (stream_invokeExprs.HasNext)
				{
					DebugLocation(96, 29);
					adaptor.AddChild(root_1, stream_invokeExprs.NextTree());

				}
				stream_invokeExprs.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("dot", 14);
			LeaveRule("dot", 14);
			LeaveRule_dot();
		}
		DebugLocation(96, 41);
		} finally { DebugExitRule(GrammarFileName, "dot"); }
		return retval;

	}
	// $ANTLR end "dot"

	partial void EnterRule_term();
	partial void LeaveRule_term();

	// $ANTLR start "term"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:98:1: term : ( ID LPAREN ( invokeExprs )? RPAREN -> ^( ImplicitInvoke ID ( invokeExprs )? ) | IF ^ expr THEN ! expr ELSE ! expr FI !| WHILE ^ expr LOOP ! expr POOL !| LCURLY ( expr SEMI )+ RCURLY -> ^( Exprs ( expr )+ ) | LET ^ letExprs IN ! expr SEMI !| CASE ^ expr OF ! ( caseExpr )+ ESAC !| NEW ^ typeName SEMI !| LPAREN expr RPAREN -> ^( Expr expr ) | ID ^| INTEGER ^| STRING ^| TRUE ^| FALSE ^| VOID ^| SELF ^);
	[GrammarRule("term")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> term()
	{
		EnterRule_term();
		EnterRule("term", 15);
		TraceIn("term", 15);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ID60 = default(CommonToken);
		CommonToken LPAREN61 = default(CommonToken);
		CommonToken RPAREN63 = default(CommonToken);
		CommonToken IF64 = default(CommonToken);
		CommonToken THEN66 = default(CommonToken);
		CommonToken ELSE68 = default(CommonToken);
		CommonToken FI70 = default(CommonToken);
		CommonToken WHILE71 = default(CommonToken);
		CommonToken LOOP73 = default(CommonToken);
		CommonToken POOL75 = default(CommonToken);
		CommonToken LCURLY76 = default(CommonToken);
		CommonToken SEMI78 = default(CommonToken);
		CommonToken RCURLY79 = default(CommonToken);
		CommonToken LET80 = default(CommonToken);
		CommonToken IN82 = default(CommonToken);
		CommonToken SEMI84 = default(CommonToken);
		CommonToken CASE85 = default(CommonToken);
		CommonToken OF87 = default(CommonToken);
		CommonToken ESAC89 = default(CommonToken);
		CommonToken NEW90 = default(CommonToken);
		CommonToken SEMI92 = default(CommonToken);
		CommonToken LPAREN93 = default(CommonToken);
		CommonToken RPAREN95 = default(CommonToken);
		CommonToken ID96 = default(CommonToken);
		CommonToken INTEGER97 = default(CommonToken);
		CommonToken STRING98 = default(CommonToken);
		CommonToken TRUE99 = default(CommonToken);
		CommonToken FALSE100 = default(CommonToken);
		CommonToken VOID101 = default(CommonToken);
		CommonToken SELF102 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> invokeExprs62 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr65 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr67 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr69 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr72 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr74 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr77 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> letExprs81 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr83 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr86 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> caseExpr88 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName91 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr94 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ID60_tree = default(CommonTree);
		CommonTree LPAREN61_tree = default(CommonTree);
		CommonTree RPAREN63_tree = default(CommonTree);
		CommonTree IF64_tree = default(CommonTree);
		CommonTree THEN66_tree = default(CommonTree);
		CommonTree ELSE68_tree = default(CommonTree);
		CommonTree FI70_tree = default(CommonTree);
		CommonTree WHILE71_tree = default(CommonTree);
		CommonTree LOOP73_tree = default(CommonTree);
		CommonTree POOL75_tree = default(CommonTree);
		CommonTree LCURLY76_tree = default(CommonTree);
		CommonTree SEMI78_tree = default(CommonTree);
		CommonTree RCURLY79_tree = default(CommonTree);
		CommonTree LET80_tree = default(CommonTree);
		CommonTree IN82_tree = default(CommonTree);
		CommonTree SEMI84_tree = default(CommonTree);
		CommonTree CASE85_tree = default(CommonTree);
		CommonTree OF87_tree = default(CommonTree);
		CommonTree ESAC89_tree = default(CommonTree);
		CommonTree NEW90_tree = default(CommonTree);
		CommonTree SEMI92_tree = default(CommonTree);
		CommonTree LPAREN93_tree = default(CommonTree);
		CommonTree RPAREN95_tree = default(CommonTree);
		CommonTree ID96_tree = default(CommonTree);
		CommonTree INTEGER97_tree = default(CommonTree);
		CommonTree STRING98_tree = default(CommonTree);
		CommonTree TRUE99_tree = default(CommonTree);
		CommonTree FALSE100_tree = default(CommonTree);
		CommonTree VOID101_tree = default(CommonTree);
		CommonTree SELF102_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_invokeExprs=new RewriteRuleSubtreeStream(adaptor,"rule invokeExprs");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(98, 8);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:98:5: ( ID LPAREN ( invokeExprs )? RPAREN -> ^( ImplicitInvoke ID ( invokeExprs )? ) | IF ^ expr THEN ! expr ELSE ! expr FI !| WHILE ^ expr LOOP ! expr POOL !| LCURLY ( expr SEMI )+ RCURLY -> ^( Exprs ( expr )+ ) | LET ^ letExprs IN ! expr SEMI !| CASE ^ expr OF ! ( caseExpr )+ ESAC !| NEW ^ typeName SEMI !| LPAREN expr RPAREN -> ^( Expr expr ) | ID ^| INTEGER ^| STRING ^| TRUE ^| FALSE ^| VOID ^| SELF ^)
			int alt23=15;
			try { DebugEnterDecision(23, false);
			switch (input.LA(1))
			{
			case ID:
				{
				int LA23_1 = input.LA(2);

				if ((LA23_1==LPAREN))
				{
					alt23 = 1;
				}
				else if ((LA23_1==ATSIGN||LA23_1==COMMA||(LA23_1>=DIV && LA23_1<=EQUAL)||LA23_1==FI||(LA23_1>=GE && LA23_1<=GT)||LA23_1==IN||LA23_1==LE||LA23_1==LOOP||LA23_1==LT||(LA23_1>=MINUS && LA23_1<=MULT)||LA23_1==OF||(LA23_1>=PLUS && LA23_1<=RPAREN)||LA23_1==SEMI||LA23_1==THEN))
				{
					alt23 = 9;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 23, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case IF:
				{
				alt23 = 2;
				}
				break;
			case WHILE:
				{
				alt23 = 3;
				}
				break;
			case LCURLY:
				{
				alt23 = 4;
				}
				break;
			case LET:
				{
				alt23 = 5;
				}
				break;
			case CASE:
				{
				alt23 = 6;
				}
				break;
			case NEW:
				{
				alt23 = 7;
				}
				break;
			case LPAREN:
				{
				alt23 = 8;
				}
				break;
			case INTEGER:
				{
				alt23 = 10;
				}
				break;
			case STRING:
				{
				alt23 = 11;
				}
				break;
			case TRUE:
				{
				alt23 = 12;
				}
				break;
			case FALSE:
				{
				alt23 = 13;
				}
				break;
			case VOID:
				{
				alt23 = 14;
				}
				break;
			case SELF:
				{
				alt23 = 15;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 23, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:99:4: ID LPAREN ( invokeExprs )? RPAREN
				{
				DebugLocation(99, 4);
				ID60=(CommonToken)Match(input,ID,Follow._ID_in_term557);  
				stream_ID.Add(ID60);

				DebugLocation(99, 7);
				LPAREN61=(CommonToken)Match(input,LPAREN,Follow._LPAREN_in_term559);  
				stream_LPAREN.Add(LPAREN61);

				DebugLocation(99, 14);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:99:14: ( invokeExprs )?
				int alt20=2;
				try { DebugEnterSubRule(20);
				try { DebugEnterDecision(20, false);
				int LA20_0 = input.LA(1);

				if ((LA20_0==CASE||LA20_0==FALSE||(LA20_0>=ID && LA20_0<=IF)||(LA20_0>=INTEGER && LA20_0<=ISVOID)||LA20_0==LCURLY||LA20_0==LET||LA20_0==LPAREN||(LA20_0>=NEG && LA20_0<=NOT)||LA20_0==SELF||LA20_0==STRING||LA20_0==TRUE||LA20_0==VOID||LA20_0==WHILE))
				{
					alt20 = 1;
				}
				} finally { DebugExitDecision(20); }
				switch (alt20)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:99:14: invokeExprs
					{
					DebugLocation(99, 14);
					PushFollow(Follow._invokeExprs_in_term561);
					invokeExprs62=invokeExprs();
					PopFollow();

					stream_invokeExprs.Add(invokeExprs62.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(20); }

				DebugLocation(99, 27);
				RPAREN63=(CommonToken)Match(input,RPAREN,Follow._RPAREN_in_term564);  
				stream_RPAREN.Add(RPAREN63);



				{
				// AST REWRITE
				// elements: ID, invokeExprs
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 99:34: -> ^( ImplicitInvoke ID ( invokeExprs )? )
				{
					DebugLocation(99, 37);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:99:37: ^( ImplicitInvoke ID ( invokeExprs )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(99, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ImplicitInvoke, "ImplicitInvoke"), root_1);

					DebugLocation(99, 54);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(99, 57);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:99:57: ( invokeExprs )?
					if (stream_invokeExprs.HasNext)
					{
						DebugLocation(99, 57);
						adaptor.AddChild(root_1, stream_invokeExprs.NextTree());

					}
					stream_invokeExprs.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:100:4: IF ^ expr THEN ! expr ELSE ! expr FI !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(100, 6);
				IF64=(CommonToken)Match(input,IF,Follow._IF_in_term580); 
				IF64_tree = (CommonTree)adaptor.Create(IF64);
				root_0 = (CommonTree)adaptor.BecomeRoot(IF64_tree, root_0);
				DebugLocation(100, 8);
				PushFollow(Follow._expr_in_term583);
				expr65=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr65.Tree);
				DebugLocation(100, 17);
				THEN66=(CommonToken)Match(input,THEN,Follow._THEN_in_term585); 
				DebugLocation(100, 19);
				PushFollow(Follow._expr_in_term588);
				expr67=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr67.Tree);
				DebugLocation(100, 28);
				ELSE68=(CommonToken)Match(input,ELSE,Follow._ELSE_in_term590); 
				DebugLocation(100, 30);
				PushFollow(Follow._expr_in_term593);
				expr69=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr69.Tree);
				DebugLocation(100, 37);
				FI70=(CommonToken)Match(input,FI,Follow._FI_in_term595); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:101:4: WHILE ^ expr LOOP ! expr POOL !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(101, 9);
				WHILE71=(CommonToken)Match(input,WHILE,Follow._WHILE_in_term602); 
				WHILE71_tree = (CommonTree)adaptor.Create(WHILE71);
				root_0 = (CommonTree)adaptor.BecomeRoot(WHILE71_tree, root_0);
				DebugLocation(101, 11);
				PushFollow(Follow._expr_in_term605);
				expr72=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr72.Tree);
				DebugLocation(101, 20);
				LOOP73=(CommonToken)Match(input,LOOP,Follow._LOOP_in_term607); 
				DebugLocation(101, 22);
				PushFollow(Follow._expr_in_term610);
				expr74=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr74.Tree);
				DebugLocation(101, 31);
				POOL75=(CommonToken)Match(input,POOL,Follow._POOL_in_term612); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:102:4: LCURLY ( expr SEMI )+ RCURLY
				{
				DebugLocation(102, 4);
				LCURLY76=(CommonToken)Match(input,LCURLY,Follow._LCURLY_in_term619);  
				stream_LCURLY.Add(LCURLY76);

				DebugLocation(102, 11);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:102:11: ( expr SEMI )+
				int cnt21=0;
				try { DebugEnterSubRule(21);
				while (true)
				{
					int alt21=2;
					try { DebugEnterDecision(21, false);
					int LA21_0 = input.LA(1);

					if ((LA21_0==CASE||LA21_0==FALSE||(LA21_0>=ID && LA21_0<=IF)||(LA21_0>=INTEGER && LA21_0<=ISVOID)||LA21_0==LCURLY||LA21_0==LET||LA21_0==LPAREN||(LA21_0>=NEG && LA21_0<=NOT)||LA21_0==SELF||LA21_0==STRING||LA21_0==TRUE||LA21_0==VOID||LA21_0==WHILE))
					{
						alt21 = 1;
					}


					} finally { DebugExitDecision(21); }
					switch (alt21)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:102:12: expr SEMI
						{
						DebugLocation(102, 12);
						PushFollow(Follow._expr_in_term622);
						expr77=expr();
						PopFollow();

						stream_expr.Add(expr77.Tree);
						DebugLocation(102, 17);
						SEMI78=(CommonToken)Match(input,SEMI,Follow._SEMI_in_term624);  
						stream_SEMI.Add(SEMI78);


						}
						break;

					default:
						if (cnt21 >= 1)
							goto loop21;

						EarlyExitException eee21 = new EarlyExitException( 21, input );
						DebugRecognitionException(eee21);
						throw eee21;
					}
					cnt21++;
				}
				loop21:
					;

				} finally { DebugExitSubRule(21); }

				DebugLocation(102, 24);
				RCURLY79=(CommonToken)Match(input,RCURLY,Follow._RCURLY_in_term628);  
				stream_RCURLY.Add(RCURLY79);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 102:31: -> ^( Exprs ( expr )+ )
				{
					DebugLocation(102, 34);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:102:34: ^( Exprs ( expr )+ )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(102, 36);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Exprs, "Exprs"), root_1);

					DebugLocation(102, 42);
					if (!(stream_expr.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_expr.HasNext )
					{
						DebugLocation(102, 42);
						adaptor.AddChild(root_1, stream_expr.NextTree());

					}
					stream_expr.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:103:4: LET ^ letExprs IN ! expr SEMI !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(103, 7);
				LET80=(CommonToken)Match(input,LET,Follow._LET_in_term642); 
				LET80_tree = (CommonTree)adaptor.Create(LET80);
				root_0 = (CommonTree)adaptor.BecomeRoot(LET80_tree, root_0);
				DebugLocation(103, 9);
				PushFollow(Follow._letExprs_in_term645);
				letExprs81=letExprs();
				PopFollow();

				adaptor.AddChild(root_0, letExprs81.Tree);
				DebugLocation(103, 20);
				IN82=(CommonToken)Match(input,IN,Follow._IN_in_term647); 
				DebugLocation(103, 22);
				PushFollow(Follow._expr_in_term650);
				expr83=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr83.Tree);
				DebugLocation(103, 31);
				SEMI84=(CommonToken)Match(input,SEMI,Follow._SEMI_in_term652); 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:104:4: CASE ^ expr OF ! ( caseExpr )+ ESAC !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(104, 8);
				CASE85=(CommonToken)Match(input,CASE,Follow._CASE_in_term658); 
				CASE85_tree = (CommonTree)adaptor.Create(CASE85);
				root_0 = (CommonTree)adaptor.BecomeRoot(CASE85_tree, root_0);
				DebugLocation(104, 10);
				PushFollow(Follow._expr_in_term661);
				expr86=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr86.Tree);
				DebugLocation(104, 17);
				OF87=(CommonToken)Match(input,OF,Follow._OF_in_term663); 
				DebugLocation(104, 19);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:104:19: ( caseExpr )+
				int cnt22=0;
				try { DebugEnterSubRule(22);
				while (true)
				{
					int alt22=2;
					try { DebugEnterDecision(22, false);
					int LA22_0 = input.LA(1);

					if ((LA22_0==ID))
					{
						alt22 = 1;
					}


					} finally { DebugExitDecision(22); }
					switch (alt22)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:104:19: caseExpr
						{
						DebugLocation(104, 19);
						PushFollow(Follow._caseExpr_in_term666);
						caseExpr88=caseExpr();
						PopFollow();

						adaptor.AddChild(root_0, caseExpr88.Tree);

						}
						break;

					default:
						if (cnt22 >= 1)
							goto loop22;

						EarlyExitException eee22 = new EarlyExitException( 22, input );
						DebugRecognitionException(eee22);
						throw eee22;
					}
					cnt22++;
				}
				loop22:
					;

				} finally { DebugExitSubRule(22); }

				DebugLocation(104, 33);
				ESAC89=(CommonToken)Match(input,ESAC,Follow._ESAC_in_term669); 

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:105:4: NEW ^ typeName SEMI !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(105, 7);
				NEW90=(CommonToken)Match(input,NEW,Follow._NEW_in_term675); 
				NEW90_tree = (CommonTree)adaptor.Create(NEW90);
				root_0 = (CommonTree)adaptor.BecomeRoot(NEW90_tree, root_0);
				DebugLocation(105, 9);
				PushFollow(Follow._typeName_in_term678);
				typeName91=typeName();
				PopFollow();

				adaptor.AddChild(root_0, typeName91.Tree);
				DebugLocation(105, 22);
				SEMI92=(CommonToken)Match(input,SEMI,Follow._SEMI_in_term680); 

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:106:4: LPAREN expr RPAREN
				{
				DebugLocation(106, 4);
				LPAREN93=(CommonToken)Match(input,LPAREN,Follow._LPAREN_in_term686);  
				stream_LPAREN.Add(LPAREN93);

				DebugLocation(106, 11);
				PushFollow(Follow._expr_in_term688);
				expr94=expr();
				PopFollow();

				stream_expr.Add(expr94.Tree);
				DebugLocation(106, 16);
				RPAREN95=(CommonToken)Match(input,RPAREN,Follow._RPAREN_in_term690);  
				stream_RPAREN.Add(RPAREN95);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 106:23: -> ^( Expr expr )
				{
					DebugLocation(106, 26);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:106:26: ^( Expr expr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(106, 28);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr, "Expr"), root_1);

					DebugLocation(106, 33);
					adaptor.AddChild(root_1, stream_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:107:4: ID ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(107, 6);
				ID96=(CommonToken)Match(input,ID,Follow._ID_in_term703); 
				ID96_tree = (CommonTree)adaptor.Create(ID96);
				root_0 = (CommonTree)adaptor.BecomeRoot(ID96_tree, root_0);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:108:4: INTEGER ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(108, 11);
				INTEGER97=(CommonToken)Match(input,INTEGER,Follow._INTEGER_in_term709); 
				INTEGER97_tree = (CommonTree)adaptor.Create(INTEGER97);
				root_0 = (CommonTree)adaptor.BecomeRoot(INTEGER97_tree, root_0);

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:109:4: STRING ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(109, 10);
				STRING98=(CommonToken)Match(input,STRING,Follow._STRING_in_term715); 
				STRING98_tree = (CommonTree)adaptor.Create(STRING98);
				root_0 = (CommonTree)adaptor.BecomeRoot(STRING98_tree, root_0);

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:110:4: TRUE ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(110, 8);
				TRUE99=(CommonToken)Match(input,TRUE,Follow._TRUE_in_term721); 
				TRUE99_tree = (CommonTree)adaptor.Create(TRUE99);
				root_0 = (CommonTree)adaptor.BecomeRoot(TRUE99_tree, root_0);

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:111:4: FALSE ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(111, 9);
				FALSE100=(CommonToken)Match(input,FALSE,Follow._FALSE_in_term727); 
				FALSE100_tree = (CommonTree)adaptor.Create(FALSE100);
				root_0 = (CommonTree)adaptor.BecomeRoot(FALSE100_tree, root_0);

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:112:4: VOID ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(112, 8);
				VOID101=(CommonToken)Match(input,VOID,Follow._VOID_in_term733); 
				VOID101_tree = (CommonTree)adaptor.Create(VOID101);
				root_0 = (CommonTree)adaptor.BecomeRoot(VOID101_tree, root_0);

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:113:4: SELF ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(113, 8);
				SELF102=(CommonToken)Match(input,SELF,Follow._SELF_in_term739); 
				SELF102_tree = (CommonTree)adaptor.Create(SELF102);
				root_0 = (CommonTree)adaptor.BecomeRoot(SELF102_tree, root_0);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("term", 15);
			LeaveRule("term", 15);
			LeaveRule_term();
		}
		DebugLocation(113, 8);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_invokeExprs();
	partial void LeaveRule_invokeExprs();

	// $ANTLR start "invokeExprs"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:115:1: invokeExprs : expr ( COMMA expr )* -> ^( InvokeExprs ( expr )+ ) ;
	[GrammarRule("invokeExprs")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> invokeExprs()
	{
		EnterRule_invokeExprs();
		EnterRule("invokeExprs", 16);
		TraceIn("invokeExprs", 16);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken COMMA104 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr103 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr105 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree COMMA104_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "invokeExprs");
		DebugLocation(115, 43);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:115:12: ( expr ( COMMA expr )* -> ^( InvokeExprs ( expr )+ ) )
			DebugEnterAlt(1);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:116:2: expr ( COMMA expr )*
			{
			DebugLocation(116, 2);
			PushFollow(Follow._expr_in_invokeExprs748);
			expr103=expr();
			PopFollow();

			stream_expr.Add(expr103.Tree);
			DebugLocation(116, 7);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:116:7: ( COMMA expr )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_0 = input.LA(1);

				if ((LA24_0==COMMA))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:116:8: COMMA expr
					{
					DebugLocation(116, 8);
					COMMA104=(CommonToken)Match(input,COMMA,Follow._COMMA_in_invokeExprs751);  
					stream_COMMA.Add(COMMA104);

					DebugLocation(116, 14);
					PushFollow(Follow._expr_in_invokeExprs753);
					expr105=expr();
					PopFollow();

					stream_expr.Add(expr105.Tree);

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 116:21: -> ^( InvokeExprs ( expr )+ )
			{
				DebugLocation(116, 24);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:116:24: ^( InvokeExprs ( expr )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(116, 26);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(InvokeExprs, "InvokeExprs"), root_1);

				DebugLocation(116, 38);
				if (!(stream_expr.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_expr.HasNext )
				{
					DebugLocation(116, 38);
					adaptor.AddChild(root_1, stream_expr.NextTree());

				}
				stream_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("invokeExprs", 16);
			LeaveRule("invokeExprs", 16);
			LeaveRule_invokeExprs();
		}
		DebugLocation(116, 43);
		} finally { DebugExitRule(GrammarFileName, "invokeExprs"); }
		return retval;

	}
	// $ANTLR end "invokeExprs"

	partial void EnterRule_letExprs();
	partial void LeaveRule_letExprs();

	// $ANTLR start "letExprs"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:118:1: letExprs : localOrFieldInit ( COMMA localOrFieldInit )* -> ^( LetExprs ( localOrFieldInit )+ ) ;
	[GrammarRule("letExprs")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> letExprs()
	{
		EnterRule_letExprs();
		EnterRule("letExprs", 17);
		TraceIn("letExprs", 17);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken COMMA107 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> localOrFieldInit106 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> localOrFieldInit108 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree COMMA107_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_localOrFieldInit=new RewriteRuleSubtreeStream(adaptor,"rule localOrFieldInit");
		try { DebugEnterRule(GrammarFileName, "letExprs");
		DebugLocation(118, 76);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:118:9: ( localOrFieldInit ( COMMA localOrFieldInit )* -> ^( LetExprs ( localOrFieldInit )+ ) )
			DebugEnterAlt(1);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:119:2: localOrFieldInit ( COMMA localOrFieldInit )*
			{
			DebugLocation(119, 2);
			PushFollow(Follow._localOrFieldInit_in_letExprs774);
			localOrFieldInit106=localOrFieldInit();
			PopFollow();

			stream_localOrFieldInit.Add(localOrFieldInit106.Tree);
			DebugLocation(119, 19);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:119:19: ( COMMA localOrFieldInit )*
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=2;
				try { DebugEnterDecision(25, false);
				int LA25_0 = input.LA(1);

				if ((LA25_0==COMMA))
				{
					alt25 = 1;
				}


				} finally { DebugExitDecision(25); }
				switch ( alt25 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:119:20: COMMA localOrFieldInit
					{
					DebugLocation(119, 20);
					COMMA107=(CommonToken)Match(input,COMMA,Follow._COMMA_in_letExprs777);  
					stream_COMMA.Add(COMMA107);

					DebugLocation(119, 26);
					PushFollow(Follow._localOrFieldInit_in_letExprs779);
					localOrFieldInit108=localOrFieldInit();
					PopFollow();

					stream_localOrFieldInit.Add(localOrFieldInit108.Tree);

					}
					break;

				default:
					goto loop25;
				}
			}

			loop25:
				;

			} finally { DebugExitSubRule(25); }



			{
			// AST REWRITE
			// elements: localOrFieldInit
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 119:45: -> ^( LetExprs ( localOrFieldInit )+ )
			{
				DebugLocation(119, 48);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:119:48: ^( LetExprs ( localOrFieldInit )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(119, 50);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(LetExprs, "LetExprs"), root_1);

				DebugLocation(119, 59);
				if (!(stream_localOrFieldInit.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_localOrFieldInit.HasNext )
				{
					DebugLocation(119, 59);
					adaptor.AddChild(root_1, stream_localOrFieldInit.NextTree());

				}
				stream_localOrFieldInit.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("letExprs", 17);
			LeaveRule("letExprs", 17);
			LeaveRule_letExprs();
		}
		DebugLocation(119, 76);
		} finally { DebugExitRule(GrammarFileName, "letExprs"); }
		return retval;

	}
	// $ANTLR end "letExprs"

	partial void EnterRule_localOrFieldInit();
	partial void LeaveRule_localOrFieldInit();

	// $ANTLR start "localOrFieldInit"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:121:1: localOrFieldInit : ID COLON typeName ( ASSIGN expr )? -> ^( LocalOrFieldInit ID typeName ( expr )? ) ;
	[GrammarRule("localOrFieldInit")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> localOrFieldInit()
	{
		EnterRule_localOrFieldInit();
		EnterRule("localOrFieldInit", 18);
		TraceIn("localOrFieldInit", 18);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ID109 = default(CommonToken);
		CommonToken COLON110 = default(CommonToken);
		CommonToken ASSIGN112 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName111 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr113 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ID109_tree = default(CommonTree);
		CommonTree COLON110_tree = default(CommonTree);
		CommonTree ASSIGN112_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_typeName=new RewriteRuleSubtreeStream(adaptor,"rule typeName");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "localOrFieldInit");
		DebugLocation(121, 74);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:121:17: ( ID COLON typeName ( ASSIGN expr )? -> ^( LocalOrFieldInit ID typeName ( expr )? ) )
			DebugEnterAlt(1);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:122:2: ID COLON typeName ( ASSIGN expr )?
			{
			DebugLocation(122, 2);
			ID109=(CommonToken)Match(input,ID,Follow._ID_in_localOrFieldInit800);  
			stream_ID.Add(ID109);

			DebugLocation(122, 5);
			COLON110=(CommonToken)Match(input,COLON,Follow._COLON_in_localOrFieldInit802);  
			stream_COLON.Add(COLON110);

			DebugLocation(122, 11);
			PushFollow(Follow._typeName_in_localOrFieldInit804);
			typeName111=typeName();
			PopFollow();

			stream_typeName.Add(typeName111.Tree);
			DebugLocation(122, 20);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:122:20: ( ASSIGN expr )?
			int alt26=2;
			try { DebugEnterSubRule(26);
			try { DebugEnterDecision(26, false);
			int LA26_0 = input.LA(1);

			if ((LA26_0==ASSIGN))
			{
				alt26 = 1;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:122:21: ASSIGN expr
				{
				DebugLocation(122, 21);
				ASSIGN112=(CommonToken)Match(input,ASSIGN,Follow._ASSIGN_in_localOrFieldInit807);  
				stream_ASSIGN.Add(ASSIGN112);

				DebugLocation(122, 28);
				PushFollow(Follow._expr_in_localOrFieldInit809);
				expr113=expr();
				PopFollow();

				stream_expr.Add(expr113.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(26); }



			{
			// AST REWRITE
			// elements: expr, ID, typeName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 122:35: -> ^( LocalOrFieldInit ID typeName ( expr )? )
			{
				DebugLocation(122, 38);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:122:38: ^( LocalOrFieldInit ID typeName ( expr )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(122, 40);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(LocalOrFieldInit, "LocalOrFieldInit"), root_1);

				DebugLocation(122, 57);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(122, 60);
				adaptor.AddChild(root_1, stream_typeName.NextTree());
				DebugLocation(122, 69);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:122:69: ( expr )?
				if (stream_expr.HasNext)
				{
					DebugLocation(122, 69);
					adaptor.AddChild(root_1, stream_expr.NextTree());

				}
				stream_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("localOrFieldInit", 18);
			LeaveRule("localOrFieldInit", 18);
			LeaveRule_localOrFieldInit();
		}
		DebugLocation(122, 74);
		} finally { DebugExitRule(GrammarFileName, "localOrFieldInit"); }
		return retval;

	}
	// $ANTLR end "localOrFieldInit"

	partial void EnterRule_caseExpr();
	partial void LeaveRule_caseExpr();

	// $ANTLR start "caseExpr"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:124:1: caseExpr : ID COLON typeName HENCE expr SEMI -> ^( CaseExp ID typeName expr ) ;
	[GrammarRule("caseExpr")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> caseExpr()
	{
		EnterRule_caseExpr();
		EnterRule("caseExpr", 19);
		TraceIn("caseExpr", 19);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ID114 = default(CommonToken);
		CommonToken COLON115 = default(CommonToken);
		CommonToken HENCE117 = default(CommonToken);
		CommonToken SEMI119 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName116 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr118 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ID114_tree = default(CommonTree);
		CommonTree COLON115_tree = default(CommonTree);
		CommonTree HENCE117_tree = default(CommonTree);
		CommonTree SEMI119_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_HENCE=new RewriteRuleITokenStream(adaptor,"token HENCE");
		RewriteRuleSubtreeStream stream_typeName=new RewriteRuleSubtreeStream(adaptor,"rule typeName");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "caseExpr");
		DebugLocation(124, 65);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:124:9: ( ID COLON typeName HENCE expr SEMI -> ^( CaseExp ID typeName expr ) )
			DebugEnterAlt(1);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:125:2: ID COLON typeName HENCE expr SEMI
			{
			DebugLocation(125, 2);
			ID114=(CommonToken)Match(input,ID,Follow._ID_in_caseExpr834);  
			stream_ID.Add(ID114);

			DebugLocation(125, 5);
			COLON115=(CommonToken)Match(input,COLON,Follow._COLON_in_caseExpr836);  
			stream_COLON.Add(COLON115);

			DebugLocation(125, 11);
			PushFollow(Follow._typeName_in_caseExpr838);
			typeName116=typeName();
			PopFollow();

			stream_typeName.Add(typeName116.Tree);
			DebugLocation(125, 20);
			HENCE117=(CommonToken)Match(input,HENCE,Follow._HENCE_in_caseExpr840);  
			stream_HENCE.Add(HENCE117);

			DebugLocation(125, 26);
			PushFollow(Follow._expr_in_caseExpr842);
			expr118=expr();
			PopFollow();

			stream_expr.Add(expr118.Tree);
			DebugLocation(125, 31);
			SEMI119=(CommonToken)Match(input,SEMI,Follow._SEMI_in_caseExpr844);  
			stream_SEMI.Add(SEMI119);



			{
			// AST REWRITE
			// elements: ID, expr, typeName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 125:36: -> ^( CaseExp ID typeName expr )
			{
				DebugLocation(125, 39);
				// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:125:39: ^( CaseExp ID typeName expr )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(125, 41);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CaseExp, "CaseExp"), root_1);

				DebugLocation(125, 49);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(125, 52);
				adaptor.AddChild(root_1, stream_typeName.NextTree());
				DebugLocation(125, 61);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("caseExpr", 19);
			LeaveRule("caseExpr", 19);
			LeaveRule_caseExpr();
		}
		DebugLocation(125, 65);
		} finally { DebugExitRule(GrammarFileName, "caseExpr"); }
		return retval;

	}
	// $ANTLR end "caseExpr"

	partial void EnterRule_typeName();
	partial void LeaveRule_typeName();

	// $ANTLR start "typeName"
	// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:127:1: typeName : ( IntTypeName | BoolTypeName | StringTypeName | ObjectTypeName | SelfTypeTypeName | ID );
	[GrammarRule("typeName")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> typeName()
	{
		EnterRule_typeName();
		EnterRule("typeName", 20);
		TraceIn("typeName", 20);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken set120 = default(CommonToken);

		CommonTree set120_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "typeName");
		DebugLocation(127, 5);
		try
		{
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:128:2: ( IntTypeName | BoolTypeName | StringTypeName | ObjectTypeName | SelfTypeTypeName | ID )
			DebugEnterAlt(1);
			// C:\\Users\\KvanTTT\\Documents\\Study\\Compilators\\CompilerConstruction\\CoolCompiler\\CoolGrammar.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(128, 2);

			set120=(CommonToken)input.LT(1);
			if (input.LA(1)==BoolTypeName||input.LA(1)==ID||input.LA(1)==IntTypeName||input.LA(1)==ObjectTypeName||input.LA(1)==SelfTypeTypeName||input.LA(1)==StringTypeName)
			{
				input.Consume();
				adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set120));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

			catch (RecognitionException e) {
		//throw e;
			}

		finally
		{
			TraceOut("typeName", 20);
			LeaveRule("typeName", 20);
			LeaveRule_typeName();
		}
		DebugLocation(133, 5);
		} finally { DebugExitRule(GrammarFileName, "typeName"); }
		return retval;

	}
	// $ANTLR end "typeName"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _classDef_in_program181 = new BitSet(new ulong[]{0x0UL,0x8UL});
		public static readonly BitSet _SEMI_in_program183 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _CLASS_in_classDef204 = new BitSet(new ulong[]{0x2000040400000080UL,0xA0UL});
		public static readonly BitSet _typeName_in_classDef206 = new BitSet(new ulong[]{0x202000000000UL});
		public static readonly BitSet _INHERITS_in_classDef209 = new BitSet(new ulong[]{0x2000040400000080UL,0xA0UL});
		public static readonly BitSet _typeName_in_classDef211 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _LCURLY_in_classDef215 = new BitSet(new ulong[]{0x400000000UL,0x1UL});
		public static readonly BitSet _featureList_in_classDef217 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _RCURLY_in_classDef219 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _feature_in_featureList245 = new BitSet(new ulong[]{0x0UL,0x8UL});
		public static readonly BitSet _SEMI_in_featureList247 = new BitSet(new ulong[]{0x400000002UL});
		public static readonly BitSet _ID_in_feature270 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _LPAREN_in_feature272 = new BitSet(new ulong[]{0x400000000UL,0x2UL});
		public static readonly BitSet _formalList_in_feature275 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _RPAREN_in_feature279 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _COLON_in_feature281 = new BitSet(new ulong[]{0x2000040400000080UL,0xA0UL});
		public static readonly BitSet _typeName_in_feature283 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _LCURLY_in_feature285 = new BitSet(new ulong[]{0xE04A0CC04000200UL,0x5414UL});
		public static readonly BitSet _expr_in_feature287 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _RCURLY_in_feature289 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _localOrFieldInit_in_feature316 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _formal_in_formalList325 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _COMMA_in_formalList328 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _formal_in_formalList330 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _ID_in_formal348 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _COLON_in_formal350 = new BitSet(new ulong[]{0x2000040400000080UL,0xA0UL});
		public static readonly BitSet _typeName_in_formal353 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_expr362 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ASSIGN_in_expr364 = new BitSet(new ulong[]{0xE04A0CC04000200UL,0x5414UL});
		public static readonly BitSet _not_in_expr369 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_not380 = new BitSet(new ulong[]{0xE04A0CC04000200UL,0x5414UL});
		public static readonly BitSet _relation_in_not385 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _addition_in_relation394 = new BitSet(new ulong[]{0x8400180400002UL});
		public static readonly BitSet _LE_in_relation398 = new BitSet(new ulong[]{0x604A0CC04000200UL,0x5414UL});
		public static readonly BitSet _LT_in_relation403 = new BitSet(new ulong[]{0x604A0CC04000200UL,0x5414UL});
		public static readonly BitSet _GE_in_relation408 = new BitSet(new ulong[]{0x604A0CC04000200UL,0x5414UL});
		public static readonly BitSet _GT_in_relation413 = new BitSet(new ulong[]{0x604A0CC04000200UL,0x5414UL});
		public static readonly BitSet _EQUAL_in_relation418 = new BitSet(new ulong[]{0x604A0CC04000200UL,0x5414UL});
		public static readonly BitSet _addition_in_relation422 = new BitSet(new ulong[]{0x8400180400002UL});
		public static readonly BitSet _multiplication_in_addition433 = new BitSet(new ulong[]{0x4040000000000002UL});
		public static readonly BitSet _PLUS_in_addition437 = new BitSet(new ulong[]{0x604A0CC04000200UL,0x5414UL});
		public static readonly BitSet _MINUS_in_addition442 = new BitSet(new ulong[]{0x604A0CC04000200UL,0x5414UL});
		public static readonly BitSet _multiplication_in_addition446 = new BitSet(new ulong[]{0x4040000000000002UL});
		public static readonly BitSet _isvoid_in_multiplication456 = new BitSet(new ulong[]{0x80000000080002UL});
		public static readonly BitSet _MULT_in_multiplication460 = new BitSet(new ulong[]{0x604A0CC04000200UL,0x5414UL});
		public static readonly BitSet _DIV_in_multiplication465 = new BitSet(new ulong[]{0x604A0CC04000200UL,0x5414UL});
		public static readonly BitSet _isvoid_in_multiplication469 = new BitSet(new ulong[]{0x80000000080002UL});
		public static readonly BitSet _ISVOID_in_isvoid480 = new BitSet(new ulong[]{0x604A0CC04000200UL,0x5414UL});
		public static readonly BitSet _neg_in_isvoid485 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEG_in_neg494 = new BitSet(new ulong[]{0x604A04C04000200UL,0x5414UL});
		public static readonly BitSet _dot_in_neg499 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _term_in_dot507 = new BitSet(new ulong[]{0x100022UL});
		public static readonly BitSet _ATSIGN_in_dot511 = new BitSet(new ulong[]{0x2000040400000080UL,0xA0UL});
		public static readonly BitSet _typeName_in_dot513 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _DOT_in_dot517 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _ID_in_dot519 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _LPAREN_in_dot521 = new BitSet(new ulong[]{0xE04A0CC04000200UL,0x5416UL});
		public static readonly BitSet _invokeExprs_in_dot523 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _RPAREN_in_dot526 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_term557 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _LPAREN_in_term559 = new BitSet(new ulong[]{0xE04A0CC04000200UL,0x5416UL});
		public static readonly BitSet _invokeExprs_in_term561 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _RPAREN_in_term564 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_term580 = new BitSet(new ulong[]{0xE04A0CC04000200UL,0x5414UL});
		public static readonly BitSet _expr_in_term583 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _THEN_in_term585 = new BitSet(new ulong[]{0xE04A0CC04000200UL,0x5414UL});
		public static readonly BitSet _expr_in_term588 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _ELSE_in_term590 = new BitSet(new ulong[]{0xE04A0CC04000200UL,0x5414UL});
		public static readonly BitSet _expr_in_term593 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _FI_in_term595 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_term602 = new BitSet(new ulong[]{0xE04A0CC04000200UL,0x5414UL});
		public static readonly BitSet _expr_in_term605 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _LOOP_in_term607 = new BitSet(new ulong[]{0xE04A0CC04000200UL,0x5414UL});
		public static readonly BitSet _expr_in_term610 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _POOL_in_term612 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_term619 = new BitSet(new ulong[]{0xE04A0CC04000200UL,0x5414UL});
		public static readonly BitSet _expr_in_term622 = new BitSet(new ulong[]{0x0UL,0x8UL});
		public static readonly BitSet _SEMI_in_term624 = new BitSet(new ulong[]{0xE04A0CC04000200UL,0x5415UL});
		public static readonly BitSet _RCURLY_in_term628 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LET_in_term642 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _letExprs_in_term645 = new BitSet(new ulong[]{0x1000000000UL});
		public static readonly BitSet _IN_in_term647 = new BitSet(new ulong[]{0xE04A0CC04000200UL,0x5414UL});
		public static readonly BitSet _expr_in_term650 = new BitSet(new ulong[]{0x0UL,0x8UL});
		public static readonly BitSet _SEMI_in_term652 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CASE_in_term658 = new BitSet(new ulong[]{0xE04A0CC04000200UL,0x5414UL});
		public static readonly BitSet _expr_in_term661 = new BitSet(new ulong[]{0x1000000000000000UL});
		public static readonly BitSet _OF_in_term663 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _caseExpr_in_term666 = new BitSet(new ulong[]{0x400800000UL});
		public static readonly BitSet _ESAC_in_term669 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_term675 = new BitSet(new ulong[]{0x2000040400000080UL,0xA0UL});
		public static readonly BitSet _typeName_in_term678 = new BitSet(new ulong[]{0x0UL,0x8UL});
		public static readonly BitSet _SEMI_in_term680 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_term686 = new BitSet(new ulong[]{0xE04A0CC04000200UL,0x5414UL});
		public static readonly BitSet _expr_in_term688 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _RPAREN_in_term690 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_term703 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTEGER_in_term709 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_term715 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRUE_in_term721 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FALSE_in_term727 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VOID_in_term733 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SELF_in_term739 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_invokeExprs748 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _COMMA_in_invokeExprs751 = new BitSet(new ulong[]{0xE04A0CC04000200UL,0x5414UL});
		public static readonly BitSet _expr_in_invokeExprs753 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _localOrFieldInit_in_letExprs774 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _COMMA_in_letExprs777 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _localOrFieldInit_in_letExprs779 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _ID_in_localOrFieldInit800 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _COLON_in_localOrFieldInit802 = new BitSet(new ulong[]{0x2000040400000080UL,0xA0UL});
		public static readonly BitSet _typeName_in_localOrFieldInit804 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _ASSIGN_in_localOrFieldInit807 = new BitSet(new ulong[]{0xE04A0CC04000200UL,0x5414UL});
		public static readonly BitSet _expr_in_localOrFieldInit809 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_caseExpr834 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _COLON_in_caseExpr836 = new BitSet(new ulong[]{0x2000040400000080UL,0xA0UL});
		public static readonly BitSet _typeName_in_caseExpr838 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _HENCE_in_caseExpr840 = new BitSet(new ulong[]{0xE04A0CC04000200UL,0x5414UL});
		public static readonly BitSet _expr_in_caseExpr842 = new BitSet(new ulong[]{0x0UL,0x8UL});
		public static readonly BitSet _SEMI_in_caseExpr844 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace CoolCompiler
